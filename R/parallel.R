#' Annotation function (mulitple name) parallel version
#'
#' @param row.cl Cluster object be generated by makeCluster
#' @param ... Other parameters see \code{\link{annotation.merge}}
#' @export
#' @examples
#' if ('annovarR' %in% .packages(all.available=TRUE)){
#' library(data.table)
#' chr <- c('chr1', 'chr2', 'chr1')
#' start <- c('10020', '10020', '10020')
#' end <- c('10020', '10020', '10020')
#' ref <- c('A', 'A', 'A')
#' alt <- c('-', '-', '-')
#' database <- system.file('extdata', 'demo/hg19_avsnp147.txt', package = 'annovarR')
#' database.dir <- dirname(database)
#' dat <- data.table(chr = chr, start = start, end = end, ref = ref, alt = alt)
#' library(parallel)
#' row.cl <- makeCluster(2)
#' x <- parAnnotation(dat = dat, anno.names = c('avsnp147', '1000g2015aug_all'), 
#' database.dir = database.dir, db.type = 'txt', row.cl = row.cl)
#' stopCluster(row.cl)
#' }
parAnnotation <- function(row.cl, ...) {
  row.cl.num <- length(row.cl)
  params <- list(...)
  dat <- params$dat
  dat <- splitList(dat, row.cl.num)
  if (row.cl.num > length(dat)) {
    row.cl.num <- length(dat)
  }
  x <- NULL
  registerDoParallel(row.cl)
  clusterExport(row.cl, "row.cl.num", envir = environment())
  clusterExport(row.cl, "params", envir = environment())
  clusterExport(row.cl, "dat", envir = environment())
  print(params)
  print(dat)
  print(row.cl.num)
  result <- foreach(x = 1:row.cl.num, .packages = "annovarR") %dopar% {
    params.pre <- params
    params.pre[["dat"]] <- NULL
    params <- params.pre
    dat.pre <- list()
    dat.pre["dat"] <- dat[x]
    params["dat"] <- dat.pre["dat"]
    params$dat <- as.data.table(params$dat)
    result <- do.call(annotation.merge, params)
  }
  result <- do.call(rbindlist, list(result))
  print(result)
  return(result)
}

#' Annotation function for big file
#'
#' @param filename Path of input data
#' @param out.txt Path of output annotation infomation
#' @param new.colnames New colnames of table, default is to retain the original (File mode only)
#' @param new.colnames.order New colnames order in table (File mode only)
#' @param cores.avail Available core num can be used by annovarR
#' @param batch.row.cl.num Default is 5 (recommend)
#' @param min.split.rows Default is 1e+06, if lower this value, annovarR will not to split the input data (no more than 5e+06)
#' @param fwrite.params Other parameters pass to \code{\link[data.table]{fwrite}}
#' @param ff.tmp.dir The default ff object stored dir. [Defautle is tempdir()]
#' @param ... Other parameters see \code{\link{parAnnotation}}
#' @export
#' @examples
#' library(data.table)
#' chr <- c('chr1', 'chr2', 'chr1')
#' start <- c('10020', '10020', '10020')
#' end <- c('10020', '10020', '10020')
#' ref <- c('A', 'A', 'A')
#' alt <- c('-', '-', '-')
#' database <- system.file('extdata', 'demo/hg19_avsnp147.txt', package = 'annovarR')
#' database.dir <- dirname(database)
#' dat <- data.table(chr = chr, start = start, end = end, ref = ref, alt = alt)
parAnnotation.big.file <- function(filename = "", out.txt = "", new.colnames = NULL, 
  cores.avail = detectCores(logical = F), batch.row.cl.num = 5, min.split.rows = 1e+06, 
  new.colnames.order = NULL, fwrite.params = list(sep = "\t"), ff.tmp.dir = tempdir(), 
  ...) {
  max.batch.num <- ceiling(cores.avail/batch.row.cl.num)
  params <- list(...)
  if (filename != "") {
    file.row.num <- nrow(fread(filename, select = 1L))
    if (is.null(new.colnames)) {
      file.colnames <- colnames(fread(filename, nrows = 2))
    } else {
      file.colnames <- new.colnames
    }
  }
  is.dat.mode <- filename == "" && ("dat" %in% names(params) && nrow(params$dat) != 
    0)
  if (is.dat.mode) {
    file.row.num <- nrow(params$dat)
  }
  
  if (file.row.num >= 5e+06) {
    split.region <- 1e+06
    max.split.num <- file.row.num/split.region
  } else if (file.row.num > min.split.rows) {
    split.region <- 5e+05
    max.split.num <- file.row.num/split.region
  } else {
    split.region <- file.row.num
    max.split.num <- 1
  }
  max.split.num <- ceiling(max.split.num)
  split.seq <- 1:max.split.num
  if (is.dat.mode) {
    dat <- params[["dat"]]
  }
  split.file.list <- list()
  split.anno.out.list <- list()
  for (i in split.seq) {
    split.file <- tempfile()
    if (is.dat.mode) {
      if (i != max(split.seq)) {
        start <- (1 + (split.region * (i - 1)))
        end <- split.region * i
      } else {
        start <- (1 + (split.region * (i - 1)))
        end <- file.row.num
      }
      region <- start:end
      dat.tmp <- dat[region, ]
    } else {
      skip <- split.region * (i - 1)
      if (i != max(split.seq)) {
        dat.tmp <- fread(filename, skip = skip, nrows = split.region)
      } else {
        dat.tmp <- fread(filename, skip = skip, nrows = -1)
      }
      if (is.null(new.colnames.order)) {
        colnames(dat.tmp)[1:length(file.colnames)] <- file.colnames
      } else {
        colnames(dat.tmp)[new.colnames.order] <- file.colnames
      }
    }
    params[["dat"]] <- dat.tmp
    out.file <- tempfile()
    split.anno.out.list[[i]] <- out.file
    params.file <- tempfile()
    params.extra <- list(out.file = out.file)
    params.extra.file <- tempfile()
    save(params, file = params.file)
    save(params.extra, file = params.extra.file)
    script <- set.big.file.script(split.file, params.file, params.extra.file, 
      ff.tmp.dir, batch.row.cl.num, tempfile())
    script.tmp <- tempfile()
    writeLines(script, script.tmp, sep = "\n")
    while (TRUE) {
      lock.file.num <- length(list.files(tempdir(), "*.annovarR.lock"))
      if (lock.file.num < max.batch.num) {
        break
      } else {
        Sys.sleep(5)
      }
    }
    system(sprintf("Rscript %s", script.tmp), ignore.stderr = TRUE, ignore.stdout = TRUE, 
      wait = FALSE)
  }
  while (TRUE) {
    out.file <- split.anno.out.list
    is.finished <- all(file.exists(sprintf("%s", out.file)))
    if (is.finished) {
      break
    } else {
      Sys.sleep(5)
    }
  }
  result <- NULL
  if (file.exists(out.txt)) {
    file.remove(out.txt)
  }
  for (x in split.seq) {
    result.tmp <- NULL
    result.tmp <- fread(split.anno.out.list[[x]])
    fwrite(result.tmp, out.txt, append = TRUE, na = fixed("NA"), sep = "\t")
  }
}

# Set parAnnotation.big.file script
set.big.file.script <- function(split.file = "", params.file = "", params.extra.file = "", 
  ff.tmp.dir = "", batch.row.cl.num = 5, lock.file = tempfile()) {
  script <- sprintf(paste0("library(annovarR);library(parallel);library(data.table);", 
    "load('%s');load('%s');options(fftempdir = '%s');", "params$row.cl <- makeCluster(%s);", 
    "if (!'dat' %s names(params)){params$dat <- fread('%s')};", "lock.file <- '%s.annovarR.lock';file.create(lock.file);", 
    "result.tmp <- do.call(parAnnotation, params);", "stopCluster(params$row.cl);", 
    "file.remove(lock.file);", "fwrite(result.tmp, file = params.extra$out.file, na = 'NA');"), 
    params.file, params.extra.file, ff.tmp.dir, batch.row.cl.num, "%in%", split.file, 
    lock.file)
  
}

# Function to split list and distributed to different computing core len is the
# number of core X is the list object
splitList <- function(X, len) {
  len <- ceiling(length(X[[1]])/len)
  a <- seq(from = 1, to = length(X[[1]]), by = len)
  b <- seq(from = len, to = length(X[[1]]), by = len)
  if (length(b) < length(a)) {
    b <- c(b, length(X[[1]]))
  }
  result <- NULL
  for (i in 1:length(a)) {
    result[[i]] <- lapply(X, function(x) x[a[i]:b[i]])
  }
  return(result)
}
